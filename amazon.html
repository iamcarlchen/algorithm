<!DOCTYPE html>
<html lang="en">
  <head>
  </head>
  <body>
    <script>
      /**
 * @param {number[]} nums
 * @return {number}
 */
var minimumOperations = function (nums) {
    var len = nums.length;

    var operations = 0;
    var m = {};
    for (var i = 0; i < len; i++) {
        var n = nums[i];
        if (n > 0 && !m[n]) {
            m[n] = true;
            operations++;
        }
    }

    return operations;
};


/**
 * @param {string} s
 * @param {number[][]} queries
 * @return {number[]}
 */
var platesBetweenCandles = function (s, queries) {
    if (queries == null) {
        return null;
    }

    var A = [];
    for (var i = 0; i < s.length; i++) {
        if (s[i] == '|') {
            A.push(i);
        }
    }

    var binarySearch = function (arr, d, lower) {
        var left = 0;
        var right = arr.length - 1;
        while (left <= right) {
            var mid = Math.floor((right + left) / 2);
            if (d < arr[mid]) {
                right = mid - 1;
                if (right < 0) {
                    return lower ? 0 : -1;
                }
            } else if (d > arr[mid]) {
                left = mid + 1;
                if (left > arr.length - 1) {
                    return lower ? -1 : arr.length - 1;
                }
            } else {
                return mid;
            }
        }
        if (lower) {
            return left > right ? left : left + 1;
        } else {
            return left > right ? right : right - 1;
        }
    }

    var result = [];
    for (var q = 0; q < queries.length; q++) {
        var i = binarySearch(A, queries[q][0], true);
        var j = binarySearch(A, queries[q][1], false);

        result.push((i < j && i >= 0 && j >= 0) ? ((A[j] - A[i]) - (j - i)) : 0);
    }

    return result;
};

// console.log(platesBetweenCandles("**|**|***|",[[2,5],[5,9]]));
// console.log(platesBetweenCandles("*|*||||**|||||||*||*||*||**|*|*||*",[[2,33],[2,32],[3,31],[0,33],[1,24],[3,20],[7,11],[5,32],[2,31],[5,31],[0,31],[3,28],[4,33],[6,29],[2,30],[2,28],[1,30],[1,33],[4,32],[5,30],[4,23],[0,30],[3,10],[5,28],[0,28],[4,28],[3,33],[0,27]]));
// console.log(platesBetweenCandles("*|*||||**|||||||*||*||*||**|*|*||*",[[3,28]]));
// console.log(platesBetweenCandles("|||||*|||*|||*||||*||||**|*|||**|**||**|||*|||*||***||*|*||",[[30,49]]));


     /**
 * @param {string} s
 * @return {string}
 */
var reorganizeString = function (s) {
    var len = s.length;
    if (len <= 1) {
        return s;
    }

    var map = {};
    var maxc = null;
    var max = 0;
    for (var i = 0; i < len; i++) {
        var c = s.charAt(i);

        if (map[c]) {
            map[c] = map[c] + 1;
        } else {
            map[c] = 1;
        }

        if (map[c] > max) {
            max = map[c];
            maxc = c;
        }
    }

    // restore rest character as array 'rest'
    var rest = [];
    for (var k in map) {
        if (k != maxc) {
            for (var i = 0; i < map[k]; i++) {
                rest.push(k);
            }
        }
    }

    //Compute the max number of map values "n", gap is equal n-1
    // S-max < max-1
    // S+1<2 *max
    // (S+1)/2 < max
    if (rest.length < max - 1) {
        return "";
    }

    var s = [];
    var idx = 0;
    while (max > 0) {
        s[idx] = maxc;
        idx += 2;
        max--;
    }

    for (var k in map) {
        if (k != maxc) {
            while (map[k] > 0) {
                if (idx >= len) {
                    idx = 1;
                }
                s[idx] = k;
                idx += 2;
                map[k] = map[k] - 1;
            }
        }
    }

    return s.join('');
};
// console.log(reorganizeString("aab"))
// console.log(reorganizeString("aabaaaaaa"));


/**
 * @param {string} str1
 * @param {string} str2
 * @return {boolean}
 */
var canMakeSubsequence = function (str1, str2) {
    var len1 = str1.length;
    var len2 = str2.length;

    if (len2 > len1) {
        return false;
    }

    var idx = 0;
    for (var i = 0; i <= len2 - 1; i++) {
        var c = str2.charAt(i);
        var t = (c == 'a') ? 'z' : String.fromCharCode(c.charCodeAt() - 1);

        while (idx < len1 && (str1.charAt(idx) != c && str1.charAt(idx) != t)) {
            idx++;
        }

        if (idx >= len1) {
            return false;
        }
        idx++;
    }

    return true;
};
// console.log(canMakeSubsequence("ab","d"));
// console.log(canMakeSubsequence("om","nm"));
// console.log(canMakeSubsequence("oh","hu"));


/**
 * @param {string[]} username
 * @param {number[]} timestamp
 * @param {string[]} website
 * @return {string[]}
 */
var mostVisitedPattern = function (username, timestamp, website) {
    var len = username.length;

    //compute a map which store evevy t&w of every user;
    var userMap = {};
    for (var i = 0; i < len; i++) {
        var u = username[i];
        var t = timestamp[i];
        var w = website[i];

        var arr = userMap[u];
        if (!arr) {
            arr = [];
        }
        arr.push({
            t: t, w: w
        });
        userMap[u] = arr;
    }

    var countMap = {};
    var maxS = "";
    var maxNum = 0;
    for (var u in userMap) {
        var arr = userMap[u];

        //sort by time;
        arr = arr.sort(function (a, b) {
            return a.t - b.t;
        });

        var l = arr.length;

        var ucount = {};

        for (var i = 0; i < l; i++) {
            for (var j = i + 1; j < l; j++) {
                for (var k = j + 1; k < l; k++) {
                    var s = arr[i].w + " " + arr[j].w + " " + arr[k].w;
                    if (!ucount[s]) {
                        if (!countMap[s]) {
                            countMap[s] = 1;
                        } else {
                            countMap[s] = countMap[s] + 1;
                        }
                        ucount[s] = true;
                    }

                    //compareTo
                    if (countMap[s] > maxNum || (countMap[s] == maxNum && maxS.localeCompare(s) > 0)) {
                        maxNum = countMap[s];
                        maxS = s;
                    }
                }
            }
        }
    }

    return maxS.split(" ");
};


/**
 * @param {number[]} nums
 * @return {number}
 */
var getMaxLen = function (nums) {
    var positive = 0;
    var negative = 0;

    var ans = 0;
    for (var i =0;i<nums.length;i++) {
        var n = nums[i];
        if (n == 0) {
            positive = 0;
            negative = 0;
        } else if (n > 0) {
            positive++;
            negative = negative == 0 ? 0 : negative + 1;
        } else {
            var tmp = positive;
            positive = negative == 0 ? 0 : (negative + 1);
            negative = tmp + 1;
        }

        ans = Math.max(ans, positive);
    }

    return ans;
};
// console.log(getMaxLen([1,-2,-3,4]));


/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {
    var n = grid.length;
    var m = grid[0].length;

    var dfs = function (g, i, j) {
        if (i < 0 || j < 0 || i >= n || j >= m || g[i][j] == '0') {
            return;
        }

        grid[i][j] = '0';

        dfs(g, i, j + 1);
        dfs(g, i, j - 1);
        dfs(g, i + 1, j);
        dfs(g, i - 1, j);
    }

    var count = 0;
    for (var i = 0; i < n; i++) {
        for (var j = 0; j < m; j++) {
            var c = grid[i][j];
            if (c == '1') {
                dfs(grid, i, j);
                count++;
            }
        }
    }

    return count;
};

/**
 * @param {number[]} nums
 * @return {number}
 */
var minimumSwaps = function (nums) {
    var max = nums.length - 1;
    var min = 0;

    for (var i = 1; i < nums.length; i++) {
        if (nums[i] < nums[min]) {
            min = i;
        }

        if (nums[nums.length - i - 1] > nums[max]) {
            max = nums.length - i - 1;
        }
    }

    return min + nums.length - 1 - max - (min > max ? 1 : 0)
};

class Graph
{
    // Constructor
    constructor(v)
    {
        this.V = v;
        this.adj = new Array(v);
        for(let i = 0; i < v; i++)
            this.adj[i] = [];
    }
         
    // Function to add an edge into the graph
    addEdge(v, w)
    {
        // Add w to v's list.
        this.adj[v].push(w);
    }
         
    // Prints BFS traversal from a given source s
    BFS(s)
    {
        // Mark all the vertices as not visited(By default
        // set as false)
        let visited = new Array(this.V);
        for(let i = 0; i < this.V; i++)
            visited[i] = false;
             
        // Create a queue for BFS
        let queue=[];
             
        // Mark the current node as visited and enqueue it
        visited[s]=true;
        queue.push(s);
             
        while(queue.length>0)
        {
            // Dequeue a vertex from queue and print it
            s = queue[0];
            console.log(s+" ");
            queue.shift();
                 
            // Get all adjacent vertices of the dequeued
            // vertex s. 
            // If an adjacent has not been visited,
            // then mark it visited and enqueue it
            this.adj[s].forEach((adjacent,i) => { 
                if(!visited[adjacent])
                {
                    visited[adjacent]=true;
                    queue.push(adjacent);
                }
            });
        }
    }

    // A function used by DFS
    DFSUtil(v, visited)
    {
         
        // Mark the current node as visited and print it
        visited[v] = true;
        console.log(v + " ");
  
        // Recur for all the vertices adjacent to this
        // vertex
        for(let i of this.adj[v].values())
        {
            let n = i
            if (!visited[n])
                this.DFSUtil(n, visited);
        }
    }
     
    // The function to do DFS traversal.
    // It uses recursive
    // DFSUtil()
    DFS(v)
    {
         
        // Mark all the vertices as
        // not visited(set as
        // false by default in java)
        let visited = new Array(this.V);
        for(let i = 0; i < this.V; i++)
            visited[i] = false;
  
        // Call the recursive helper
        // function to print DFS
        // traversal
        this.DFSUtil(v, visited);
    }
}


// Driver program to test methods of graph class
     
    // Create a graph given in the above diagram
    var g = new Graph(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);
    console.log(g);

    console.log("Following is Breadth First Traversal " +
                "(starting from vertex 2) ");
    g.BFS(2);
     

     console.log("Following is Depth First Traversal " + 
               "(starting from vertex 2)");
 
    g.DFS(2);
// This code is contributed by Aman Kumar.


/**
 * @param {number[]} arr
 * @return {number}
 */
var maximumElementAfterDecrementingAndRearranging = function (arr) {
    arr.sort(function(a,b){
        return a-b;
    });
    console.log(arr)

    var len = arr.length;

    var pre = 0;
    for (var i = 0; i < len; i++) {
        pre = Math.min(pre + 1, arr[i]);
    }

    return pre;
};

/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function (n) {
    var result = []

    var backtrack = function (result, str, open, close, max) {
        if (str.length == max * 2) {
            result.push(str);
            return;
        }

        if (open < max) {
            backtrack(result, str + "(", open + 1, close, max);
        }
        if (close < open) {
            backtrack(result, str + ")", open, close + 1, max);
        }
    }

    backtrack(result, "", 0, 0, n);

    return result;
};


    </script>
  </body>
</html>
